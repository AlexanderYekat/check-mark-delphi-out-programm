═══════════════════════════════════════════════════════════
  КОДИРОВАНИЕ МАРОК В BASE64
═══════════════════════════════════════════════════════════

📋 ФОРМАТ МАРКИ:
-----------------

1. Обычная марка (из сканера/базы):
   "014494550435306821QXYXSALGLMYQQ" + Символ(29) + "91EE06"
   
   где Символ(29) - это GS (Group Separator)

2. Марка в Base64 (для передачи в Delphi):
   "MDE0NDk0NTUwNDM1MzA2ODIxUVhZWFNBTEdMTVlRURw5MUVFMDYcOTJ..."
   
   Закодирована функцией Base64Строка()


🔧 КОДИРОВАНИЕ В 1С:
---------------------

Функция: ЗакодироватьМаркуВBase64(МаркаОбычная)

Пример использования:

```bsl
МаркаОбычная = "014494550435306821QXYXSALGLMYQQ" + Символ(29) + "91EE06";
МаркаBase64 = ЗакодироватьМаркуВBase64(МаркаОбычная);

// Добавляем в структуру
Марка = Новый Структура;
Марка.Вставить("Позиция", 1);
Марка.Вставить("КодМаркировкиBase64", МаркаBase64);
Марка.Вставить("ПланируемыйСтатус", "штучный товар, реализован");
```

Внутри функции:
```bsl
ЗаписьДанных = Новый ЗаписьДанных();
ЗаписьДанных.ЗаписатьСимволы(МаркаОбычная);
МаркаBase64 = Base64Строка(ЗаписьДанных.ЗакрытьИПолучитьДвоичныеДанные());
```


🔓 ДЕКОДИРОВАНИЕ В DELPHI:
---------------------------

Функция: ProcessMarkCode(var Mark: TInputMark)

Вызывается автоматически при загрузке CSV!

```pascal
// ДЕКОДИРУЕМ ИЗ BASE64
DecodedBytes := TNetEncoding.Base64.DecodeStringToBytes(Mark.MarkCodeBase64);
Mark.MarkCode := TEncoding.UTF8.GetString(DecodedBytes);

// Извлекаем КИ (до #29)
SeparatorPos := Pos(#29, Mark.MarkCode);
Mark.MarkCodeKI := Copy(Mark.MarkCode, 1, SeparatorPos - 1);
```


📊 ТРИ ВЕРСИИ КОДА МАРКИ:
--------------------------

После загрузки в Delphi марка существует в трех форматах:

1. MarkCodeBase64 (исходный)
   "MDE0NDk0NTUwNDM1MzA2ODIxUVhZWFNBTEdMTVlRURw5MUVFMDYcOTJ..."
   → Используется для хранения
   → Записывается в output_results.csv

2. MarkCode (декодированный)
   "014494550435306821QXYXSALGLMYQQ" + #29 + "91EE06"
   → Используется для проверки на ККТ
   → Передается в драйвер

3. MarkCodeKI (контрольная идентификация)
   "014494550435306821QXYXSALGLMYQQ"
   → Часть до #29
   → Используется для идентификации товара


🔄 ПРОЦЕСС ОБРАБОТКИ:
----------------------

1С: 
  МаркаОбычная (с Символ(29))
    ↓
  ЗакодироватьМаркуВBase64()
    ↓
  МаркаBase64
    ↓
  CSV файл

Delphi:
  CSV файл
    ↓
  LoadInputMarksFromCSV()
    ↓
  ProcessMarkCode() → ДЕКОДИРУЕТ Base64!
    ↓
  MarkCode (с #29)
  MarkCodeKI (до #29)


💡 ВАЖНО:
----------

✅ 1С ВСЕГДА кодирует марку в Base64 перед записью в CSV
✅ Delphi ВСЕГДА декодирует Base64 при загрузке CSV
✅ НЕ нужно вручную заменять \u001d на #29
✅ Base64 автоматически сохраняет все спецсимволы


📝 ПРИМЕР ПОЛНОГО ЦИКЛА:
-------------------------

1С:
```bsl
// Получаем марку со сканера
МаркаСоСканера = "01234..." + Символ(29) + "91EE06";

// Кодируем в Base64
МаркаBase64 = ЗакодироватьМаркуВBase64(МаркаСоСканера);

// Добавляем в массив
Марка = Новый Структура;
Марка.Вставить("КодМаркировкиBase64", МаркаBase64);
МассивМарок.Добавить(Марка);

// Записываем CSV
ЗаписатьМаркиДляПроверки(МассивМарок, ПараметрыЧека);
```

Delphi:
```pascal
// Загружаем CSV
LoadInputMarksFromCSV();
  → ProcessMarkCode() автоматически декодирует Base64
  → FInputMarks[0].MarkCode = "01234..." + #29 + "91EE06"
  → FInputMarks[0].MarkCodeKI = "01234..."

// Проверяем на ККТ
fptr.setParam(MARKING_CODE, MarkCode); // Используем декодированную версию
```


🛡️ ЗАЩИТА ОТ ОШИБОК:
----------------------

Если декодирование Base64 не удалось:
  → MarkCode = MarkCodeBase64 (как есть)
  → Логируется ошибка
  → Программа продолжает работу


═══════════════════════════════════════════════════════════
  Версия: 2.0 | Дата: 2025-01-10
═══════════════════════════════════════════════════════════

